---
layout: post
title: Interacting with your Xcode projects in Swift
excerpt: This tiny blog post contains some thoughts on the rants I often see about apps written in Electron and what's my opinion on the framework and the apps written with it.
comments-issue-number: 31
tags: [electron, web, desktop apps, js, electronjs]
---

One of the core parts of Tuist is [`xcodeproj`](https://github.com/tuist/xcodeproj), a Swift library that allows you to read, update and write Xcode projects. Tuist leverages the tool to generate projects and provide a convenient and friendly interface to your Xcode projects. The main gateway to modify Xcode projects is Xcode, the official IDE from Apple. Xcode knows the structure of the project and converts your actions within the project into changes in the project files. We barely have to touch those files ourselves, only if we get git conflicts and need to move some lines around.

However, there are certain situations where it might be useful to do some automation on those files, for example, to detect references to files that don’t exist, or invalid build settings. Even though you could check those things by parsing the file yourself and traversing the structure, you can do it more conveniently with `xcodeproj` which not only provides you with an API in Swift, but makes sure that your changes in the project file are persisted with the format that Xcode.

In this blog post, I’ll talk about the project and its structure, and jump into some use cases where you might consider introducing some automation in your projects with `xcodeproj`. 

## Xcodeproj, a monolithic format

The Xcode project, which has an extension `xcodeproj` *(where the name of the library comes from)*, is a folder that contains several files that define different components of the project. One of the most interesting and complex files is the file `project.pbxproj`. You might  be familiar with it if you have run into git conflicts on Xcode projects before. This is a [property list file](TODO), like the `Info.plist`, but with a subtle difference that made implementing `xcodeproj` a challenge. The file has some custom annotations that Xcode adds along the file to make the format more human-readable and *(I'm guessing this one)* facilitate resolving git conflicts. Since the format is not documented, the library required several iterations to approximate very accurately the format of Xcode. 

> We’d like to thank everyone who contributed to the project by reporting issues or fixing them directly. Thanks to their help, `xcodeproj` is now part of internal tools at companies like [Pinterest](https://pinterest.com) or [Lyft](https://lyft.com).

The `pbxproj` file contains a large list of objects, which in `xcodeproj` are modelled as `PBXObject` classes. They represent elements such as build phases *(`PBXBuildPhase`)*, targets *(`PBXNativeTarget`)* or files *(`PBXFileReference`)*. Those objects get a unique identifier *(UUID)* when Xcode creates them, and it’s used to declare references between objects. For example a target has references to its build phases using their UUIDs as shown in the example below:

{% highlight plist %}
buildPhases = (
  OBJ_593 /* Sources */,
  OBJ_599 /* Frameworks */,
);
{% endhighlight %}

> The example above is from a project generated by the SPM. SPM has its own convention for naming those UUIDs, which doesn’t match Xcode’s default.

For projects like SPM or Tuist, which leverage project generation, it’s crucial to **generate the UUIDs deterministically**. In other words, every time a project is generated, its objects always get the same UUIDs. Otherwise, Xcode and its build system would invalidate the cache and cause builds to start from a clean state. `xcodeproj` uses the object attributes and the attributes of its parents to make the generated id deterministic. Moreover, the format is more aligned with the formt that Xcode uses.

## An undocumented format

Conversely to Android applications that are built using Gradle, a build system that is extensively documented, the format of Xcode projects lacks documentation. Apple expects Xcode to be the interface to the projects, consequently they barely put effort into documenting the format or making it more declarative and git-friendly.

So if the format is not documented, how were were we able to develop a Swift library that works as an alternative interface to the projects? First and foremost, thanks of the pioneering work that the wonderful [CocoaPods](https://cocoapods.org) team did in that area. They developed the first ever library to read, update and write Xcode projects, [xcodeproj](https://github.com/cocoapods/xcodeproj). The library is written in Ruby and is a core component of CocoaPods.

The work of understanding the project pretty much consists on reverse-engineering how Xcode maps actions to changes into the project files. To give you an example, let's say that we'd like to understand how the linking of a new library reflects on the project files.

1. We commit the current state of the project so that we can use git to se the diff.
2. Change the target settings to link the library.
3. Use `git diff` and see what changed.

Some of that work was already done by CocoaPods, but that did not prevent us from having to do it as well. For instance, we wanted to expose as optionals the attributes that are optionals in projects. *How did we know which attributes were optionals?* We removed them from the project, and tried to open the project with Xcode. If Xcode was able to open the project, that indicated that the attribute was optional. If Xcode crashed, it meant that the attribute was required. *Do you imagine doing that with every attribute of each object?* It was a vast amount of work, but luckily something that we don't have to do often because new Xcode versions barely introduce new attributes.

## Hands-on examples

I could write a some blog posts explaining each of the objects and exhaust you with a some theory, but I thought it'd be better to take you through some practical examples that you could write yourself to get familiar with the objects. Before we dive into them, we need to create a new Swift executable package where we'll add `xcodeproj` as a dependency. Let's create a folder and initialize a package:

{% highlight bash %}
mkdir examples
cd examples
swift package init --type executable
{% endhighlight %}

The commands above will create a manifest file, `Package.swift`, and a `Sources/examples` directory with a `main.swift` file where we'll write our examples.
Next up, we need to add `xcodeproj` as a dependency. Edit the `Package.swift` and add the following dependencies to the `dependencies` array:

{% highlight swift %}
.package(url: "https://github.com/tuist/xcodeproj.git", .upToNextMajor(from: "6.5.0")),
{% endhighlight %}

> Replace `6.5.0` with the version of xcodeproj that you'd like to use.

That's all we need to start playing with the examples. Remember to `import xcodeproj` at the top of the `main.swift` file.

### Example 1: Generate an empty project
In this example we'll write some Swift lines to create an empty Xcode project. *Exciting, isn't it?* If you every wondered what Xcode does when you click `File > New Project`, you'll learn it with this example. You'll realize that after all, creating an Xcode project is not as complex as it might seem. **You could write your own Xcode project generator**. Let me dump some code here and navigate you through it right after:


### Example 2: Get the linked frameworks and libraries of a target

### Example 3: Detect duplicated source files

