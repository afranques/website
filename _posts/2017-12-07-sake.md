---
layout: post
title: Tasks automation in Swift with Sake
excerpt: In this post I introduce a new tool I've been working on Sake. Sake is the Swift version of Make. It allows you to automate tasks in your projects.
tags: [sake, swift, swift, xcproj, xcode.swift]
comments: true
image:
  feature: headers/beyonce.jpg
  credit: Pedro Pi√±era
sitemap   :
  priority : 0.9
  isfeatured : 1
---

In the past are those days when you automated your tasks using Make, Rake or Fastlane. These tools provided an interface an tools to automate certain tasks in our projects. Each of them had their own strenghts and weaknesses. If we take Make for instance, it requires some bash knowledge, but on the other side it is more robust than the other solution *(it does't depend on anything that is not in your system)*. Rake or Fastlane made the definition of our tasks easier using a more readable language like Ruby, but they required to install some dependencies. Fastlane for example comes with some dependencies that need to be installed in the system using Ruby gems.

While those tools made our lives easier as developers, I felt we could leverage Swift and its types to automate tasks, using Xcode and its editor to build and test our tasks easily. I started to work on the Swift version of Make that I'm pleased to introduce in this post, [Sake](https://github.com/xcodeswift/sake). It's in a very early stage but ready to be used. I'm eager to get feedback from you and improve the tool with your help. Please don't hesitate to contribute with the repo or propose ideas!

## Why Sake?
I'm Swift/Objective-C developer and I'm very used to work with compilers that catch any issues with the types in our code. Types are a very powerful tool and used properly can make our apps safer bringing a lot of confidence to the developer. In most of the projects that I've been involved, either open or closed source, the automation was mainly done using bash or Ruby and tools like Rake or Fastlane. Many times I've been myself trying to debug failing lanes or tasks using `pry` in Ruby or printing stuff in the console to analyze the execution of the task. Sometimes these issues happened on CI and I spent a lot of time debugging them until I could figure out where the issue was coming from. Does it sound familiar to you?

I read about how Swift Package Manager works and saw that [Danger](http://danger.systems/) did something similar and after some grooming I realized it was feasible to build a Swift Make where the definition of the tasks would be in a Swift file. What I liked about the idea is the fact that developers would be able to write the scripts in a language they are familiar with. They don't need to know about the Ruby syntax, or how to debug Ruby execution. Moreover they could use an IDE like Xcode that they are very used to. The tool would facilitate testing and composition by allowing developers to separate their tasks in multiple `.swift` files that are part of the same module.

{% highlight swift %}
// Sakefile
import SakefileDescription
import SakefileUtils

enum Task: String, CustomStringConvertible {
  case build
  var description: String {
    switch self {
      case .build:
        return "Builds the project"
    }
  }
}

Sake<Task> {
  $0.task(.build) { (utils) in
    // Here is where you define your build task
  }
}.run()
{% endhighlight %}

## How it works

Sake is based on the same Swift Package Manager foundation but with some subtle differences. In case of Swift Package Manager, the tool compiles your `Package.swift` file exporting the variable as a [TOML](https://github.com/toml-lang/toml) file *(a format similar to json yet more human-readable)*. Afterwards they parse that TOML file and map it into models that define the structure of your project.

> If you are interested in reading more about that, I'd recommend you to check out this [blogpost]() that explains it further.

In case of Sake it doesn't need to generate any toml file since the tasks are not value properties but closures that contain the actions. Rather, Sake compiles the file passing some arguments that are used by the `Sake` class to determine what needs to be done *(e.g. list all the tasks, or run a particular task)*. [This class](https://github.com/xcodeswift/sake/blob/master/Sources/SakeKit/RunSakefile.swift#L34) contains all the logic that compiles and runs the `Sakefile.swift` file. Notice that we need to pass some flags that specify where the libraries are. This is very important, otherwise the compiler will throw an error when you try to compile the `Sakefile.swift` because it doesn't know where to import the `SakefileDescription` library from.

## How to use it

#### Install the tool

First of all you need to install the tool. You can easily do it with Homebrew:

{% highlight bash %}
brew tap xcodeswift/sake git@github.com:xcodeswift/sake.git
brew install sake
{% endhighlight %}

Notice that you have to add the repository tap. A tap in Homebrew is a repository that contains formulas, and formulas are Ruby classes that specify how to install a given tool. I plan to add the formulat to the official Homebrew tap so that you don't have to add any external tap, but it's pending task to do.

#### Generate your Sakefile.swift

Once you have the tool installed you should be able to run the following command from the console:

{% highlight bash %}
sake init
{% endhighlight %}

`sake init` will generate a base `Sakefile.swift` in the current directory where you can start defining your tasks.

Notice that `Sake` is a generic class where the type must be an enum that contains all possible tasks. That makes the definition of your tasks more type-safe since you can define dependencies between tasks by passing the type rather than a string with its name.

#### Generate the Xcode project

You can edit the file above using any text editor. That's a good thing to do if you want to practise how familiar you are with the Swift syntax and `Foundation` APIs but is that something that you'd like to practise? What if we could use Xcode and benefit from the syntax highlighting and the code autocompletion that the IDE offers? What if I told you that Sake can help you with that?

Run the following command in the console:

{% highlight bash %}
sake generate-xcodeproj
{% endhighlight %}

The command will generate a `Sakefile.xcpdeproj` project in the directory where the `Sakefile.swift` is. The project contains a command-line-tool target with your `Sakefile.swift` and the linking settings necessary for Xcode to recognize the tool libraries.

> :warning: Xcode expect command-line-tool targets to contain a `main.swift` file that is the entry point of the command line tool. That's an implicit value that we can't change. If you try to compile the scheme you'll see that Xcode complains because you cannot run code at the top level in files other than the `main.swift` file. Ignore the error since it will work when the `Sakefile.swift` is run by Sake.

#### Running tasks

Running tasks is very easy. You just need to run the following command where `name` is the name of the task:

{% highlight bash %}
sake task name
{% endhighlight %}

That would run the task erroring if the task failed *(by throwing a Swift error)*. Sake also provides a command that you can use to print all the available tasks:

{% highlight bash %}
sake tasks
{% endhighlight %}

## Sake utils
//TODO

## Limitation
- Swift ABI
- Xcode and main.swift

### What's next?
- Facilitate testing.
- Support .swift files from Sake folder.
- Officially include the formula in the Homebrew tap.
- Improve utils.
- Version `SakefileDescription`.